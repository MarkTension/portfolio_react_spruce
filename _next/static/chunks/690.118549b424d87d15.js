"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[690],{95690:function(t,e,i){i.r(e),e.default="# Neural Cellular Automata and Swarming\n\nHere's some documentation on my endeavors with putting [Neural Cellular Automata (NCA)](https://distill.pub/2020/growing-ca/) into a flock of BOIDS. Why? \n- Artistic purposes\n- Understand NCA more intimately\n- Since NCA is quite robust to noise, I want to see how far this can be pushed\n- It might help with coming up with new project ideas. \n\n<p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BYt77BIho1E\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</p>\n\nSo how does it work? I started with my standard flocking code. \nThen added a new buffer containing for each boid the 4-number state, which is also each boids' color.\n\nNormally NCA updates each pixel/state by looking at that of the 8 neighboring pixels. \nIt's less straightforward for a dynamic system like BOIDS. We'll have to approximate what the neighbors are by looking at each direction around it. Then we take the closest boid in each direction. \n\nHere's part of the WGSL code to understand it in a bit more detail.\n\n```HLSL\nlet diff = other.position - posotion;\nlet high = 99999.9;\nlet start = vec4f(0.01)\nvar neighborDistances = array<f32, 8>(high, high, high, high, high, high, high, high);\nvar neighborCaStates = array<vec4f, 8>(start, start, start, start, start, start, start, start);\n\nif (dist < uniforms.detectionRange) {\n  let angle = atan2(diff.y, diff.x);\n  // get int (topleft=0, top=1, etc bottomRight=8) representing the direction\n  let direction = classify_position(angle, v);\n\n  if (direction != -1) {\n    let curSmallestDist = neighborDistances[direction];\n    if (dist < curSmallestDist) {\n      neighborCaStates[direction] = agents[i].caState;\n      neighborDistances[direction] = dist;\n    }\n  }\n```\n\nSo for the NCA update rule implementation I used [this example](https://www.shadertoy.com/view/slGGzD) from shadertoy and adapted it to my WGSL code. For a long while I thought it didn't work, but after long painful night of debugging it turned out I wrote a row-major order vs column-major order matrix multiplication.\n\n### Reflections\nI'm quite happy on how it turned out (see video above), and I have some more ideas on how to improve it.\nAlso less difficult than I thought it'd be with all the examples and documentation available. Honestly, most time went into scaling it up by implementing tiling and figuring out how to get radix sort to work.\n\nAlso, it turns out NCA robustness to noise works well, because the patterns are undeniably similar to the original while it's far from exact what the boid's neighbor is.\n\nThen one more trick you can do is, when determining the neigbors, take the neighbors based on the BOID's direction instead of the absolute neighbor. This works quite well too. Some of the parts of the video have this, and it results in effects less true to how the patterns are trained, but cool in another way.\n\nAlso what gave some interesting effects is letting the colors affect the boid's steering parameters. This gives a super cool interplay, never fully stabilizing a pattern.**"}}]);