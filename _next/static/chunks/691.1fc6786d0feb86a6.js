"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[691],{72691:function(n,t,e){e.r(t),t.default="# My favorite webgpu random function\n\nI thought it was worth sharing this for it's value, but also understanding the implementation gave me a more intimate understanding of some fundamental CS concepts: hashing, bitwise casting, and 32bit number layouts.\n\n### What I did before:\nThe quickest and most prevalent way to get random values that are roughly uniform is using this fraction and sinus option with a random seed as input:\n\n```\ny = fract(sin(x)*43758.5453123);\n```\n\nBook of shaders has a [great piece](https://thebookofshaders.com/10/) on it.\n\nIt's not fully uniform though. Density is slightly higher at the center. I can encourage you to play around with the interactive function and see what happens with different input values.\n\nAlso, introducing quite high values of the seed above 1M results in artifacts because of precision errors in the sine function. These high seeds are not uncommon in my simulations: e.g. when using the particle index. It's preventable, but introduces more mental friction.\n\nLooking for an alternative, I found an interesting approach I really liked [on stack overflow](https://stackoverflow.com/a/17479300/7528024). Credits to the user called 'Spatial'. The implementation used a hashing function and was hacked together in GLSL.\n\nWhat I liked was fully uncoupling from mathematical relationships by shuffling bits around with a hashing function.\n\nConverting it to WGSL resulted into this:\n\n```\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm for u32.\nfn hash_u32(x_in: u32) -> u32 {\n    var x = x_in;\n    x += (x << 10u);\n    x ^= (x >> 6u);\n    x += (x << 3u);\n    x ^= (x >> 11u);\n    x += (x << 15u);\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfn float_construct_from_u32(m_in: u32) -> f32 {\n    let ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    let ieeeOne = 0x3F800000u;      // 1.0 in IEEE binary32\n\n    var m = m_in;\n    m &= ieeeMantissa;              // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                   // Add fractional part to 1.0\n\n    let f = bitcast<f32>(m);        // Range [1:2]\n    return f - 1.0;                 // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1] from a f32 seed.\nfn random_uniform(seed: f32) -> f32 {\n    return float_construct_from_u32(hash_u32(bitcast<u32>(seed)));\n}\n```\n\nRoughly it's doing the following:\n1. Bitcast the float to u32: bascially keep the same bits, but use u32 which is ideal for bitwise operations (no sign, no fractional).\n2. Hash the u32 with the hashing function: Do a number of bitwise operations to fully shuffle the bits around.\n3. Reconstruct the u32 into a float: after shuffling the bits around in the u32 layout, it's still representing a floating point (from bitcasting). We take only the mantissa part of the 32bit sequence by applying a bitmask. For layout reference:\n```\nIEEE-754 32-bit float layout:\n[sign bit (1)] [exponent (8)] [mantissa (23)]\n```\nThen it converts the mantissa to the fractional (The part after the decimal point) with a bitcast back to f32.\n\nHappy hacking"}}]);