"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[79],{34079:function(e,n,t){t.r(n),n.default="# Detecting NaN's in WebGPU\n\nNaNs can sometimes arise in WebGPU / WGSL when doing normalizations or divisions. Most important is setting up guardrails to safely do this, but sometimes it's nice to have an extra check when things _do_ go wrong. \n\nIn WGSL, it's hard to know NaNs are there, because the threads don't fail, and e.g. texture values are presented as 0's.\n\nIn other words, a thread with a NaN can turn out 'weird', but the system goes on. Only when enough threads are 'weird' you might notice it.\n\nI prefer my code just to fail, or have a compiler that complains a lot when code is questionable.\nIt's in the reason I tend to write a lot of asserts in functions, which I was inspired to do more from a conversation between John Carmack and Lex Fridman. \n\nIn WGSL there's no isnan() method.\nYou could make your own though. After searching for nan in the [WGSL Function Reference on webgpu fundamentals](https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html) I found one relevant reference:\n\n```\nfn max(e1: T, e2: T) -> T \n```\nThe documentation states that if one operand is a NaN, the other is returned.\n\nThat gives a nice hacky way to at least detect failures at critical places.\n\nYou could e.g. write e.g. a red pixel in the corner of your texture, something that you'll see. Or change a buffer value that you can load to the CPU.\n\n```\nfn if_nan_write_red_alert(x: f32) -> void {\n  let highVal = 1000000.0;\n  let x2 = min(x, highVal);\n  if (x2 == highVal){\n    writeTexture(topleft, red pixel)\n  }\n}\n```\n"}}]);