"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[79],{34079:function(e,n,t){t.r(n),n.default="# Detecting NaN's in WebGPU\n\nNaNs are bound to arise in WebGPU / WGSL. Especially when your shader writing is as eratic as mine.\n\nIt's hard to know it's happening though, because the code doesn't fail, and e.g. texture values are presented as 0's.\n\nIn other words, a thread with a NaN can turn out 'weird', but the system goes on. Only when enough threads are 'weird' you might see it. They're hard to detect.\nI prefer my code just to fail, or have a compiler that complains some more.\nIt's in the reason I tend to write a lot of asserts in functions, which I was inspired to do more from a conversation between John Carmack and Lex Fridman. \n\nIn WGSL there's no isnan() method. \nYou could make your own though. After searching for nan in the [WGSL Function Reference on webgpu fundamentals](https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html) I found one relevant reference:\n\n```\nfn max(e1: T, e2: T) -> T \n```\nThe documentation states that if one operand is a NaN, the other is returned.\n\nThat gives a nice hacky way to at least detect a nan at critical places.\nYou could e.g. write e.g. a red pixel in the corner of your texture, something that you'll see.\n\n```\nfn if_nan_write_red_alert(x: f32) -> f32 {\n  let highVal = 1000000.0;\n  let x2 = min(x, highVal);\n  if (x2 == highVal){\n    writeTexture(topleft, red pixel)\n  }\n}\n```\n\nIt's al pretty hacky, but it's also pretty useful when debugging.\n"}}]);