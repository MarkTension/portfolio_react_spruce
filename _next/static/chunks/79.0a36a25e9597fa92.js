"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[79],{34079:function(e,n,t){t.r(n),n.default="# Detecting NaN's in WebGPU\n\nNaNs are bound to arise in WebGPU. Especially when there's divisions, or when your shader writing is as eratic as mine.\n\nIn my simulation projects, NaNs tend to spread like a virus through the system: One particle can write it to a texture, which gets picked up by other particles. It's hard to know it's happening though, because the code doesn't fail, and e.g. texture values are presented as 0's.\n\nIn other words, a thread with a NaN can turn out 'weird', but the system goes on. Only when enough threads are 'weird' you might see it. NaN's are hard to detect. \n\nIdeally you'd want to raise an error if there's a NaN. It's in the same key as writing a lot of asserts in each function, which is something I like to do, inspired by a conversation between John Carmack and Lex Fridman. \n\nIn WebGPU there's no method like isnan() to detect them. You could make it yourself though. After searching for nan in the [WGSL Function Reference on webgpu fundamentals](https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html) I found two interesting references:\n```\nfn max(e1: T, e2: T) -> T \n```\nIt says: If one operand is a NaN, the other is returned.\n\nThat gives a pretty nice hacky way to at least detect a nan. \nYou could e.g. replace nan's by 0's with this:\n\n```\nfn nan_to_zero(x: f32) -> f32 {\n  let highVal = 1000000.0;\n  let x2 = min(x, highVal);\n  let x3 = select(x2, 0.000001, highVal == x2);\n  return x3;\n}\n```\n\nOr even better to write e.g. a red pixel in the corner of your texture, something which you'll see.\n\n```\nfn if_nan_write_red_alert(x: f32) -> f32 {\n  let highVal = 1000000.0;\n  let x2 = min(x, highVal);\n  if (x2 == highVal){\n    writeTexture(topleft, red pixel)\n  }\n}\n```\n\nI know, this is al quite hacky, but it's also pretty useful when debugging.\n"}}]);