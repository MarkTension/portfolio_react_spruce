"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[691],{72691:function(n,e,t){t.r(e),e.default="# My favorite webgpu random function\n\nThe quickest and most prevalent way to do randomness is using this fraction and sinus option with a random seed as input:\n\n'''\ny = fract(sin(x)*43758.5453123);\n'''\n\nBook of shaders has a [great piece](https://thebookofshaders.com/10/) on it.\n\nIt's not uniform enough though. Density is higher at the center.\n\nAlso, introducing quite high values of the seed above 1M results in artifacts because of precision errors in the sine function. These high seeds are not uncommon: e.g. when using the particle index.\n\nThe following random function I found [on stack overflow](https://stackoverflow.com/a/17479300/7528024) in GLSL by a user who hacked it together. I just really liked the use of an efficient hashing function.\n\nAfter converting it to WGSL it becomes:\n\n'''\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm for u32.\nfn hash_u32(x_in: u32) -> u32 {\n    var x = x_in;\n    x += (x << 10u);\n    x ^= (x >> 6u);\n    x += (x << 3u);\n    x ^= (x >> 11u);\n    x += (x << 15u);\n    return x;\n}\n\n// Compound hashing algorithms for vectors.\nfn hash_vec2u(v: vec2u) -> u32 {\n    return hash_u32(v.x ^ hash_u32(v.y));\n}\n\nfn hash_vec3u(v: vec3u) -> u32 {\n    return hash_u32(v.x ^ hash_u32(v.y) ^ hash_u32(v.z));\n}\n\nfn hash_vec4u(v: vec4u) -> u32 {\n    return hash_u32(v.x ^ hash_u32(v.y) ^ hash_u32(v.z) ^ hash_u32(v.w));\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfn float_construct_from_u32(m_in: u32) -> f32 {\n    let ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    let ieeeOne = 0x3F800000u;      // 1.0 in IEEE binary32\n\n    var m = m_in;\n    m &= ieeeMantissa;              // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                   // Add fractional part to 1.0\n\n    let f = bitcast<f32>(m);        // Range [1:2]\n    return f - 1.0;                 // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1] from a f32 seed.\nfn random_uniform(seed: f32) -> f32 {\n    return float_construct_from_u32(hash_u32(bitcast<u32>(seed)));\n}\n'''"}}]);