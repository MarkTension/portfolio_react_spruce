"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[704],{1023:function(e,t,n){n.r(t),t.default="# Hierarchical BOIDS, Game of Life, recursion and a model for consciousness\n\n<p align=\"center\">\n<img width= \"40%\" src=\"/images/blogHeaders/kubok.webp\" alt=\"kuboktaeder\">\n</p>\n\nThis post explores a research idea that's been on my mind. It continues on my earlier research on [how to simulate an order of magnitude more boids](https://marktension.nl/blog/order-of-magnitude-boids/), but it's less practical, more theoretical and more philosophical. I'll propose a computational model based on how increased complexity and open-endedness can arise from local rules and a recursive function. If you're familiar with it, you might notice I'm reading a lot of G\xf6del Esscher Bach lately, which was a huge inspiration for this. [Craig Reynold's BOIDS](https://cs.stanford.edu/people/eroberts/courses/soco/projects/2008-09/modeling-natural-systems/boids.html) (simulated bird flocking) is used to examplify it, and I'll extend it to a more profound example on [Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life). At the end I'll also give my own hot take on consciousness relating to this theory.\n\n### Hierarchy in programming languages - and a tangent on Erlang\nIt all started during a conversation with my Escher Think co-founder Bas on hierarchy in information systems and programming languages. \n\nSpecifically, we talked about hierarchy in the Erlang programming language (which recently gained more attention since Whatsapp was built on it). He shared that it consists of many concurrent, isolated processes that don't share state, but instead pass messages to another. \n\nIn Erlang, a processes can either be a worker or supervisor. A program has many processes and is organized hieararchically like a tree. The tree consist of sets of processes overseen by supervisors, which can in turn be overseen by higher level supervisors. That way workers can send messages up to supervisors, which can in turn have a process supervising them as well. \n\nI like how this hierarchy combined with local rules (messages) is analogous to how cognition in biology works as well, with mechanisms like predicitive coding, Carl Friston's [Free Energy principle](https://en.wikipedia.org/wiki/Free_energy_principle) and e.g. the visual pathway in the brain.\n\n### Taking swarms to the next level\nNow to BOIDS. During the conversation I started thinking of an artificial life question I've been pondering.\n\nArtificial life is so interesting because phenomena emerge from agents following local rules (like in Erlang's isolated concurrent processes). Yet I've never seen a BOID simulation get to the 'next level of complexity'. You can tweak the rules and starting state a lot to change their behavior, but it won't give an objective to the flock itself. In other words, the flock does not suddenly become an agent, and follow its own set of rules.\n\nFor that you'll have to implement a higher level process to give agency to a flock. Let's park this for now though!\n\n### Turing complete != intelligent\nI'm not saying BOIDS are necessarilly capable of higher level processes beyond swarming. But it's an intuitive emergent system to talk about, and as you'll later see a perfect simple example. \n\nAnother system which _is_ capable of computation is Cellular Automata (CA). Steven Wolfram's work is relevant here. He researched CA systems (different rule-sets) which can give emergence to compute. Especially significant is his system called [rule 110](https://en.wikipedia.org/wiki/Rule_110), which is turing complete. Same can be said about the famous Conway's Game of Life, which is also a form of CA and turing complete. These systems are can be 'taken to the next level' indefinitely.\n\nSo how is a 2D grid with rules turing complete? It allows building the components that are necessary for computation, like logic gates. [Here's a tutorial](https://www.nicolasloizeau.com/gol-computer) on how to build a computer with Game of Life. You build it by arranging it to form various logic gates, and abstract on them to build more complex processses.\n\nNevertheless, despite having a system that _can_ be turing complete, who's going to build the computer with it? Albeit interesting for many reasons, having an outsider intelligent system (the human) to build the computer is kind of a hack. It shows that it is compute-capable, but doesn't show how logic gates could evolve by themselves. Letting complexity be built by an outsider is more an argument for intelligent design. The interesting question to me is: **How does the system bootstrap itself, so that the next level of complexity can give rise to a higher level of complexity**? The higher level needs to receive an abstraction of lower-level phenomena (like Conway's logic gates) instead of only the low-detail phenomena itself. That would empower it to reach its own higher level objective. And the word _objective_ is key here as well. An objective needs to emerge. In other words: It needs agency, just like how humans have agency.\n\nEvolution has its way to do that, but I'm not familiar with computational models that explains how agency emerges succinctly. Please reach out if you can recommend any sources.\n\n### Formalizing the system\nHaving a system that self-organizes by forming increasingly complex layers on top of eachother is the goal. Let's put it into 1 function. That would please Occam's Razor.\n\nIt's still a bit vague, so let's look at the concrete BOIDS system.\n\n    [Separation, cohesion & alignment]\n\nThese are the rules of the BOIDS universe. Supreme flocking behavior. (The real universe probably has other rules: e.g. increasing kolmogorov complexity / [criticality](https://en.wikipedia.org/wiki/Self-organized_criticality) / homeostasis?)\n\nTo make it recursive:\nThe core idea is that the flock becomes a new BOID; The flock gets BOID behavior.\nOn the flock level, it does not care about BOIDS below, but instead about other flocks.\n\nSo the rules can be the exact same as lower level boids'! [Separation, cohesion & alignment] to form flocks of flocks.\nThis can be repeated indefinitely. It's a strange-loop!\n\n### How does the swarm attain agency\nThe core question is: How does the swarm attain this agency?\n\nIn this system, each layer should give rise to the next. For BOIDS you can do that by generating high-level BOIDS together with the current level BOIDS. High level boids are invisible, don't actualize until they detect and hook into a local manifestation of the emergent property, in this case flocking. The attachment of a high level BOID onto the flock is the emergence of agency. Now it must stay centered centered in the flock, and e.g. convert its own velocity signals to small signals to nudge the flock in the right direction.\n\nSo let's write this in the much anticipated recursive function:\nWe'll need to account for the perception range (which needs to grows increasingly large), and adding less boids each higher layer.\n\n```python\ndef manifest(l0_boids, l1_boids, range):\n    steer(l0_boids, range)\n    l1_boids_actualized = detect_flocking(l1_boids, range)\n    if l1_boids_actualized:\n        manifest(l1_boids_actualized, create(l2_boids, num=len(l0_boids)/10), range+1)\n```\n\nSo you can see here that the function calls itself \n\nTo build it, first step would be to hack it by hard-coding only 2 layers on a shader, [based on my earlier post](https://marktension.nl/blog/order-of-magnitude-boids/). You could pull this off on a compute shaders with some tricks, hacks and limits, but probably better would be to use something like JAX, because it's functional (which would be nice for the recursive function), and runs efficiently on the GPU.\n\n### A more general recursive function\nA more general version than BOIDS would look something like this. \n\n```python\ndef manifest(l0_x, l1_x, range):\n    behave(l0_x, range)\n    l1_x_actualized = detect_local_emergence(l1_x, range)\n    if l1_x_actualized:\n        manifest(l1_x_actualized, create(l2_x), range+1)\n```\n\n### Stepping up: Hierarchical Game of Life\n\nEven cooler than boids would be using this on Game of Life. We'd need a different emergent phenomenon to detect though. I think a good candidate would be local Kolmogorov complexity. A good read on this is [Scott Aarsonson's post titled \"Quantifying the Rise and Fall of Complexity in Closed Systems: The Coffee Automaton\"](https://scottaaronson.blog/?p=1818) where he explains how a state on the edge of chaos and order puts the system in a more dynamic state, which can be quantified by Kolmogorov complexity. I used this before in my own reserach on [quantifying interestingness in images](https://marktension.nl/blog/quantifying-interestingness-images-information-theory/).\n\nIn the Game of Life example: When high complexity manifests, a higher-level cell will arise, which operates on a larger, pooled, grid.\n\n### How does it relate to consciousness?\nHere's the wild theory. I like Giulio Tononi's \"Information integration theory of consciousness\", in which he argues that consciousness can be with:\n- differentiation – the availability of a very large number of conscious experiences\n- integration – the unity of each such experience\n\nIn other words: As soon as a system is capable of achieving enough expressivity in the number of states it can be in, and integration, Tononi would assign it a higher level of consciousness. \n\nIn my liberal interpretation, and something that I like to believe, consciousness can be treated as a universal property like gravity that just attaches itself to the system when the conditions are met, same as in our recursive function earlier.\n\nIf we pull our hierarchical GOL example through this theory, we'll find:\n- Increased hierarchy and abstraction fulfills the part of integrating information.\n- Optimizing for complexity will make the system more expressive, which yields higher criticality. Therefore it fulfills the part of differentiation.\n\nThis computational model would therefore be a way to simulate the system bootstrapping itself into higher and higher levels of consciousness. Maybe that's a step too far, but whatever. It's nice to consider it I think.\n\n### Concluding remarks\nI've had a bunch of fun writing about this. \nI like how this model addresses how complexity can keep evolving. And how systems in the universe have self-organizing criticality. There are ofcourse many other ways to go about this. Like with evolution experiments, and focusing on morphogenesis. Some notable works: [Hierarchical Neural Cellular Automata](https://direct.mit.edu/isal/proceedings/isal2023/35/20/116844), [Biomaker CA](https://google-research.github.io/self-organising-systems/2023/biomaker-ca/), and much more probably. \n\nNevertheless, I'm an outsider in this fields, using these ideas mostly for artistic purposes and my curiosity about life. These ideas represent my current state of understanding. If you spot any serious mistakes, know if anyone is doing similar research, or want to recommend me any reads, please get in touch by emailing me at tensen.mark[at]gmail[dot]com, or connecting on twitter. Would be fun to develop these ideas together.\n\nIf you happen to use this model somewhere, please cite:\n\n  Hierarchical BOIDS and Game of Life and a theoretical model for consciousness, Mark Tensen (2024, November 10) [Blog Post].\n  marktension.nl/blog/Hierarchical-boids-game-of-life-and-a-theoretical-model-for-consciousness\n"}}]);